
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Three.js Water Test</title>
  <link href="css/style.css" rel="stylesheet" />
</head>
<body>

<!-- Main THREE includes -->
<script src="lib/three.min.js"></script>
<script src="lib/Detector.js"></script>
<script src="lib/stats.js"></script>
<script src="lib/THREEx.RenderStats.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="lib/OrbitControls.js"></script>


<!-------------------->
<!-- Shaders 		-->
<!-------------------->
<!-- Render texture vertex shader. Does not modify anything. -->
<script id="vs_rt" type="x-shader/x-vertex">
//			varying vec2 vUv;
//
//			void main()
//			{
//				vUv = uv;
//
//				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
//			}
		</script>


<!-- Render texture fragment shader. Runs a simulation step. -->
<script id="fs_rt" type="x-shader/x-fragment">
			uniform sampler2D texture;
			uniform vec2 delta, mousePoint;
			uniform int mouseActive;
			uniform float damping, strength, radius;

			varying vec2 vUv;
			const float v = 3.14159;

			void main()
			{
				// get current frag value
				vec4 info = texture2D(texture, vUv);

				// Draw ripples with mouse
				if(mouseActive >= 1)
				{
					float m = max(0.0, 1.0 - length(vec2(mousePoint.x, 1.0 - mousePoint.y) - vUv) / radius);
					m = 0.5 -cos(m * v) * 0.5;
					info.r -= m * strength;
				}

				// Main wave propagation
				vec2 dx = vec2(delta.x, 0.0);
				vec2 dy = vec2(0.0, delta.y);
				float average = (
					texture2D(texture, vUv - dx).r +
					texture2D(texture, vUv - dy).r +
					texture2D(texture, vUv + dx).r +
					texture2D(texture, vUv + dy).r
				) * 0.25;
				info.g += (average - info.r) * 2.0;

				// attenuate the velocity a little so waves do not last forever
				info.g *= damping;

				// move the vertex along the velocity
				info.r += info.g;

				// damp the final value
				info.r *= damping;

				// set the new vertex height (VS uses color to determine height)
				gl_FragColor = info;
			}
		</script>


<!-- Normal map vertex shader. Sends heightmap UV to fragment shader. -->
<script id="vs_normal" type="x-shader/x-fragment">
			varying vec2 vUv;

			void main()
			{
				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>


<!-- Normal map fragment shader. Outputs to normalMap. -->
<script id="fs_normal" type="x-shader/x-fragment">
			uniform float height;
			uniform vec2 delta;
			uniform sampler2D texture;

			varying vec2 vUv;

			void main() {

				float val = texture2D( texture, vUv ).r;

				float valU = texture2D( texture, vUv + vec2( delta.x, 0.0 ) ).r;
				float valV = texture2D( texture, vUv + vec2( 0.0, delta.y ) ).r;

				gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height ) ) + 0.5 ), 1.0 );

			}
		</script>


<!-- Final pass vertex shader. Sets final mesh deformation from heightmap.
  Calculates light and eye vectors and sends them to fragment shader. -->
<script id="vs_setHeight" type="x-shader/x-vertex">
			uniform sampler2D heightMap;
			uniform float scale;
			uniform vec3 lightPos;

			varying vec3 lightVec;
			varying vec3 eyeVec;
			varying vec2 texCoord;

			void main(void)
			{

				texCoord = uv;
				vec4 info = texture2D(heightMap, texCoord);

				vec3 newpos = position;

				// Multiply new height so we can actually see the difference.
				newpos.z = info.r * scale;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( newpos, 1.0 );

				vec3 n = normalize(normalMatrix * normal);
				vec3 t = normalize(normalMatrix * vec3(1.0, 0.0, 0.0));
				vec3 b = cross(n, t);

				vec3 vVertex = vec3(modelViewMatrix * vec4(newpos, 1.0)).xyz;
				vec3 tmpVec = vec3(modelViewMatrix * vec4(lightPos.x, -lightPos.z, lightPos.y, 1.0)).xyz - vVertex;

				lightVec.x = dot(tmpVec, t);
				lightVec.y = dot(tmpVec, b);
				lightVec.z = dot(tmpVec, n);

				tmpVec = -vVertex;
				eyeVec.x = dot(tmpVec, t);
				eyeVec.y = dot(tmpVec, b);
				eyeVec.z = dot(tmpVec, n);
			}
		</script>


<!-- Final pass fragment shader. Uses normal map and light/eye positions to determine
  final shaded color. Adds ambient lighting and specular highlights. -->
<script id="fs_setColor" type="x-shader/x-fragment">
			uniform sampler2D colorMap;
			uniform sampler2D normalMap;
			uniform float invRadius;
			uniform vec3 ambient;
			uniform vec3 diffuse;
			uniform vec3 specular;
			uniform float alpha;
			uniform float shininess;

			varying vec3 lightVec;
			varying vec3 eyeVec;
			varying vec2 texCoord;

			void main (void)
			{
				float distSqr = dot(lightVec, lightVec);
				float att = clamp(1.0 - invRadius * sqrt(distSqr), 0.0, 1.0);
				vec3 lVec = lightVec * inversesqrt(distSqr);
				vec3 vVec = normalize(eyeVec);

				vec4 base = texture2D(colorMap, texCoord);
				vec3 bump = normalize( texture2D(normalMap, texCoord).xyz * 2.0 - 1.0);

				vec4 vAmbient = vec4(ambient, alpha) * vec4(ambient, alpha);

				float diffuse2 = max( dot(lVec, bump), 0.0 );
				vec4 vDiffuse = vec4(diffuse, alpha) * vec4(diffuse, alpha) * diffuse2;

				float specular2 = pow(clamp(dot(reflect(-lVec, bump), vVec), 0.0, 1.0), shininess );
				vec4 vSpecular = vec4(specular, alpha) * vec4(specular, alpha) * specular2;

				gl_FragColor = vec4((( vAmbient*base + vDiffuse*base + vSpecular ) * att).xyz, alpha);
			}
		</script>


<!-------------------->
<!-- Main Logic		-->
<!-------------------->
<script src="js/water.js"></script>

</body>
</html>
